//! Nostr identity management for Haven.
//!
//! This module provides persistent Nostr identity (nsec/npub) management.
//! The identity is used for signing Nostr events (kind 443 `KeyPackage`, etc.)
//! and providing the public key to MDK for MLS credential binding.
//!
//! # Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────┐
//! │           IdentityManager               │
//! │  - Coordinates keypair and storage      │
//! │  - Caches loaded keypair in memory      │
//! └─────────────────┬───────────────────────┘
//!                   │
//!     ┌─────────────┴─────────────┐
//!     ▼                           ▼
//! ┌───────────────┐    ┌──────────────────────┐
//! │IdentityKeypair│    │  SecureKeyStorage    │
//! │ (in memory)   │    │  (platform-provided) │
//! │ - ZeroizeOnDrop│    │  - iOS Keychain     │
//! │ - Signing     │    │  - Android Keystore  │
//! └───────────────┘    └──────────────────────┘
//! ```
//!
//! # Key Separation (Marmot Protocol)
//!
//! Per MIP-00, this Nostr identity key is separate from MLS signing keys:
//! - **Nostr identity key** (this module): Signs `KeyPackage` events, provides pubkey for MLS credentials
//! - **MLS signing keys** (MDK internal): Generated by MDK, used for MLS protocol operations
//!
//! Compromise of the Nostr identity key does NOT compromise MLS group messages.
//!
//! # Example
//!
//! ```ignore
//! use haven_core::nostr::identity::{IdentityManager, SecureKeyStorage};
//!
//! // Platform provides storage implementation
//! let storage = PlatformSecureStorage::new();
//! let manager = IdentityManager::new(storage);
//!
//! // Create or load identity
//! if !manager.has_identity()? {
//!     let identity = manager.create_identity()?;
//!     println!("Created identity: {}", identity.npub);
//! }
//!
//! // Get pubkey for MDK operations
//! let pubkey_hex = manager.pubkey_hex()?;
//! ```

mod keypair;
mod storage;

use std::sync::RwLock;

use chrono::{DateTime, Utc};
use thiserror::Error;
use zeroize::{Zeroize, Zeroizing};

pub use keypair::IdentityKeypair;
pub use storage::{SecureKeyStorage, NOSTR_IDENTITY_KEY};

#[cfg(test)]
pub use storage::tests::MockStorage;

/// Errors that can occur during identity operations.
#[derive(Error, Debug)]
pub enum IdentityError {
    /// Invalid nsec format or content.
    #[error("Invalid nsec: {0}")]
    InvalidNsec(String),

    /// No identity has been created or imported.
    #[error("No identity found")]
    NoIdentity,

    /// An identity already exists.
    #[error("Identity already exists")]
    IdentityExists,

    /// Key derivation failed.
    #[error("Key derivation failed: {0}")]
    KeyDerivation(String),

    /// Signing operation failed.
    #[error("Signing failed: {0}")]
    Signing(String),

    /// Bech32 encoding/decoding failed.
    #[error("Bech32 error: {0}")]
    Bech32(String),

    /// Storage operation failed.
    #[error("Storage error: {0}")]
    Storage(String),

    /// Lock acquisition failed (internal error).
    #[error("Lock error: {0}")]
    Lock(String),
}

/// Public identity information (safe to store and share).
///
/// This struct contains only public data derived from the identity keypair.
/// It can safely be stored in regular storage (`SQLite`, shared preferences, etc.)
/// and passed across FFI boundaries.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PublicIdentity {
    /// Public key as 64-character hex string.
    pub pubkey_hex: String,

    /// Public key in NIP-19 bech32 format (npub1...).
    pub npub: String,

    /// When this identity was created.
    pub created_at: DateTime<Utc>,
}

impl PublicIdentity {
    /// Creates a `PublicIdentity` from an `IdentityKeypair`.
    ///
    /// # Errors
    ///
    /// Returns an error if npub encoding fails.
    pub fn from_keypair(keypair: &IdentityKeypair) -> Result<Self, IdentityError> {
        Ok(Self {
            pubkey_hex: keypair.pubkey_hex(),
            npub: keypair.npub()?,
            created_at: Utc::now(),
        })
    }
}

/// Manages the user's Nostr identity.
///
/// This is the main interface for identity operations. It coordinates between
/// the keypair, secure storage, and public identity information.
///
/// # Thread Safety
///
/// The manager uses `RwLock` for interior mutability, making it safe to use
/// from multiple threads. The `SecureKeyStorage` trait requires `Send + Sync`,
/// ensuring the entire manager is thread-safe.
///
/// # Example
///
/// ```ignore
/// use haven_core::nostr::identity::{IdentityManager, MockStorage};
///
/// let storage = MockStorage::new();
/// let manager = IdentityManager::new(storage);
///
/// // Create a new identity
/// let identity = manager.create_identity().unwrap();
/// println!("Created: {}", identity.npub);
///
/// // Later, retrieve it
/// let loaded = manager.get_identity().unwrap().unwrap();
/// assert_eq!(identity.pubkey_hex, loaded.pubkey_hex);
/// ```
pub struct IdentityManager<S: SecureKeyStorage> {
    /// Platform-provided secure storage.
    storage: S,

    /// Cached keypair (loaded on demand, zeroized when manager is dropped).
    cached_keypair: RwLock<Option<IdentityKeypair>>,

    /// Cached public identity metadata.
    cached_identity: RwLock<Option<PublicIdentity>>,
}

impl<S: SecureKeyStorage> IdentityManager<S> {
    /// Creates a new identity manager with the given storage backend.
    ///
    /// # Arguments
    ///
    /// * `storage` - Platform-specific secure storage implementation
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let storage = MockStorage::new();
    /// let manager = IdentityManager::new(storage);
    /// ```
    #[must_use]
    #[allow(clippy::missing_const_for_fn)] // RwLock::new is not const
    pub fn new(storage: S) -> Self {
        Self {
            storage,
            cached_keypair: RwLock::new(None),
            cached_identity: RwLock::new(None),
        }
    }

    /// Checks if an identity exists in storage.
    ///
    /// # Errors
    ///
    /// Returns an error if the storage check fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// assert!(!manager.has_identity().unwrap());
    ///
    /// manager.create_identity().unwrap();
    /// assert!(manager.has_identity().unwrap());
    /// ```
    pub fn has_identity(&self) -> Result<bool, IdentityError> {
        self.storage.exists(NOSTR_IDENTITY_KEY)
    }

    /// Creates a new identity (generates keypair and stores it).
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::IdentityExists`] if an identity already exists.
    /// Returns a storage error if storing fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// let identity = manager.create_identity().unwrap();
    /// assert!(identity.npub.starts_with("npub1"));
    /// ```
    pub fn create_identity(&self) -> Result<PublicIdentity, IdentityError> {
        if self.has_identity()? {
            return Err(IdentityError::IdentityExists);
        }

        let keypair = IdentityKeypair::generate();
        let identity = PublicIdentity::from_keypair(&keypair)?;

        // Store secret bytes (Zeroizing wrapper auto-clears on drop)
        let secret = keypair.secret_bytes();
        self.storage.store(NOSTR_IDENTITY_KEY, secret.as_ref())?;

        // Cache the keypair and identity
        {
            let mut cache = self
                .cached_keypair
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = Some(keypair);
        }
        {
            let mut cache = self
                .cached_identity
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = Some(identity.clone());
        }

        Ok(identity)
    }

    /// Imports an identity from an nsec string.
    ///
    /// # Arguments
    ///
    /// * `nsec` - Bech32-encoded secret key starting with "nsec1"
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::IdentityExists`] if an identity already exists.
    /// Returns [`IdentityError::InvalidNsec`] if the nsec is invalid.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, IdentityKeypair, MockStorage};
    ///
    /// // Export from one manager
    /// let manager1 = IdentityManager::new(MockStorage::new());
    /// manager1.create_identity().unwrap();
    /// let nsec = manager1.export_nsec().unwrap();
    ///
    /// // Import into another
    /// let manager2 = IdentityManager::new(MockStorage::new());
    /// let identity = manager2.import_from_nsec(&nsec).unwrap();
    /// assert_eq!(identity.pubkey_hex, manager1.pubkey_hex().unwrap());
    /// ```
    pub fn import_from_nsec(&self, nsec: &str) -> Result<PublicIdentity, IdentityError> {
        if self.has_identity()? {
            return Err(IdentityError::IdentityExists);
        }

        let keypair = IdentityKeypair::from_nsec(nsec)?;
        let identity = PublicIdentity::from_keypair(&keypair)?;

        // Store secret bytes (Zeroizing wrapper auto-clears on drop)
        let secret = keypair.secret_bytes();
        self.storage.store(NOSTR_IDENTITY_KEY, secret.as_ref())?;

        // Cache the keypair and identity
        {
            let mut cache = self
                .cached_keypair
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = Some(keypair);
        }
        {
            let mut cache = self
                .cached_identity
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = Some(identity.clone());
        }

        Ok(identity)
    }

    /// Gets the public identity information.
    ///
    /// Returns `None` if no identity exists.
    ///
    /// # Errors
    ///
    /// Returns an error if loading the keypair fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// assert!(manager.get_identity().unwrap().is_none());
    ///
    /// manager.create_identity().unwrap();
    /// assert!(manager.get_identity().unwrap().is_some());
    /// ```
    pub fn get_identity(&self) -> Result<Option<PublicIdentity>, IdentityError> {
        // Return cached identity if available
        {
            let cache = self
                .cached_identity
                .read()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            if let Some(ref identity) = *cache {
                return Ok(Some(identity.clone()));
            }
        }

        // Load keypair and create identity
        self.load_keypair()?;

        // Create identity from keypair (hold read lock only during creation)
        let identity = {
            let cache = self
                .cached_keypair
                .read()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;

            match cache.as_ref() {
                Some(keypair) => Some(PublicIdentity::from_keypair(keypair)?),
                None => None,
            }
        };

        // Cache and return the identity
        if let Some(identity) = identity {
            // Update cache - lock is held only for the assignment
            #[allow(clippy::significant_drop_tightening)]
            {
                let mut identity_cache = self
                    .cached_identity
                    .write()
                    .map_err(|e| IdentityError::Lock(e.to_string()))?;
                *identity_cache = Some(identity.clone());
            }
            Ok(Some(identity))
        } else {
            Ok(None)
        }
    }

    /// Gets the public key as a hex string.
    ///
    /// This is the format needed for MDK operations.
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::NoIdentity`] if no identity exists.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// manager.create_identity().unwrap();
    ///
    /// let pubkey = manager.pubkey_hex().unwrap();
    /// assert_eq!(pubkey.len(), 64);
    /// ```
    pub fn pubkey_hex(&self) -> Result<String, IdentityError> {
        self.load_keypair()?;

        let cache = self
            .cached_keypair
            .read()
            .map_err(|e| IdentityError::Lock(e.to_string()))?;

        cache
            .as_ref()
            .map(IdentityKeypair::pubkey_hex)
            .ok_or(IdentityError::NoIdentity)
    }

    /// Exports the identity as nsec for backup.
    ///
    /// # Security Warning
    ///
    /// This exposes the secret key. Only use for user-initiated backup.
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::NoIdentity`] if no identity exists.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// manager.create_identity().unwrap();
    ///
    /// let nsec = manager.export_nsec().unwrap();
    /// assert!(nsec.starts_with("nsec1"));
    /// ```
    pub fn export_nsec(&self) -> Result<String, IdentityError> {
        self.load_keypair()?;

        let cache = self
            .cached_keypair
            .read()
            .map_err(|e| IdentityError::Lock(e.to_string()))?;

        cache
            .as_ref()
            .ok_or(IdentityError::NoIdentity)?
            .export_nsec()
    }

    /// Signs a 32-byte message hash using the identity.
    ///
    /// # Arguments
    ///
    /// * `message_hash` - The 32-byte SHA256 hash to sign
    ///
    /// # Returns
    ///
    /// The 64-byte Schnorr signature as a 128-character hex string.
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::NoIdentity`] if no identity exists.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// manager.create_identity().unwrap();
    ///
    /// let hash = [0x42u8; 32];
    /// let sig = manager.sign(&hash).unwrap();
    /// assert_eq!(sig.len(), 128);
    /// ```
    pub fn sign(&self, message_hash: &[u8; 32]) -> Result<String, IdentityError> {
        self.load_keypair()?;

        let cache = self
            .cached_keypair
            .read()
            .map_err(|e| IdentityError::Lock(e.to_string()))?;

        cache
            .as_ref()
            .ok_or(IdentityError::NoIdentity)?
            .sign(message_hash)
    }

    /// Deletes the identity from storage and clears the cache.
    ///
    /// # Errors
    ///
    /// Returns an error if the deletion fails.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use haven_core::nostr::identity::{IdentityManager, MockStorage};
    ///
    /// let manager = IdentityManager::new(MockStorage::new());
    /// manager.create_identity().unwrap();
    /// assert!(manager.has_identity().unwrap());
    ///
    /// manager.delete_identity().unwrap();
    /// assert!(!manager.has_identity().unwrap());
    /// ```
    pub fn delete_identity(&self) -> Result<(), IdentityError> {
        self.storage.delete(NOSTR_IDENTITY_KEY)?;
        self.clear_cache()?;
        Ok(())
    }

    /// Clears the cached keypair from memory.
    ///
    /// Call this when the app goes to background or when you want to
    /// force a reload from storage on next access.
    ///
    /// The cached keypair will be zeroized when replaced with `None`.
    ///
    /// # Errors
    ///
    /// Returns an error if acquiring the lock fails.
    pub fn clear_cache(&self) -> Result<(), IdentityError> {
        {
            let mut cache = self
                .cached_keypair
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = None;
        }
        {
            let mut cache = self
                .cached_identity
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = None;
        }
        Ok(())
    }

    /// Gets the raw secret bytes for external persistence.
    ///
    /// The returned bytes are wrapped in [`Zeroizing`] to ensure they are
    /// automatically zeroized when dropped.
    ///
    /// # Security Warning
    ///
    /// These bytes are the raw secret key. Handle with extreme care.
    /// Only use for persisting to platform secure storage.
    ///
    /// # Errors
    ///
    /// Returns [`IdentityError::NoIdentity`] if no identity exists.
    pub fn get_secret_bytes(&self) -> Result<Zeroizing<Vec<u8>>, IdentityError> {
        let bytes = self
            .storage
            .retrieve(NOSTR_IDENTITY_KEY)?
            .ok_or(IdentityError::NoIdentity)?;
        Ok(Zeroizing::new(bytes))
    }

    /// Stores raw secret bytes from external secure storage.
    ///
    /// Use this to restore an identity from platform secure storage on app startup.
    ///
    /// # Arguments
    ///
    /// * `secret_bytes` - 32-byte secret key from secure storage
    ///
    /// # Errors
    ///
    /// Returns an error if the bytes are invalid or storage fails.
    pub fn store_secret_bytes(&self, secret_bytes: &[u8]) -> Result<(), IdentityError> {
        if secret_bytes.len() != 32 {
            return Err(IdentityError::Storage(format!(
                "Invalid secret key length: expected 32, got {}",
                secret_bytes.len()
            )));
        }

        // Validate the secret bytes are valid (use Zeroizing for temp copy)
        let mut bytes = Zeroizing::new([0u8; 32]);
        bytes.copy_from_slice(secret_bytes);
        let _ = IdentityKeypair::from_secret_bytes(*bytes)?;

        // Store in storage backend
        self.storage.store(NOSTR_IDENTITY_KEY, secret_bytes)?;

        // Clear cache to force reload
        self.clear_cache()?;

        Ok(())
    }

    /// Loads the keypair from storage into cache if not already cached.
    fn load_keypair(&self) -> Result<(), IdentityError> {
        // Check if already cached (read lock)
        {
            let cache = self
                .cached_keypair
                .read()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            if cache.is_some() {
                return Ok(());
            }
        }

        // Try to load from storage
        if let Some(secret_bytes) = self.storage.retrieve(NOSTR_IDENTITY_KEY)? {
            // Wrap in Zeroizing for automatic cleanup
            let mut secret_bytes = Zeroizing::new(secret_bytes);

            if secret_bytes.len() != 32 {
                return Err(IdentityError::Storage(format!(
                    "Invalid secret key length: expected 32, got {}",
                    secret_bytes.len()
                )));
            }

            let mut bytes = Zeroizing::new([0u8; 32]);
            bytes.copy_from_slice(&secret_bytes);

            // Zeroize the vec before array copy is used
            secret_bytes.zeroize();

            let keypair = IdentityKeypair::from_secret_bytes(*bytes)?;

            let mut cache = self
                .cached_keypair
                .write()
                .map_err(|e| IdentityError::Lock(e.to_string()))?;
            *cache = Some(keypair);
        }

        Ok(())
    }
}

impl<S: SecureKeyStorage> std::fmt::Debug for IdentityManager<S> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let has_keypair = self
            .cached_keypair
            .read()
            .map(|c| c.is_some())
            .unwrap_or(false);
        let has_identity = self
            .cached_identity
            .read()
            .map(|c| c.is_some())
            .unwrap_or(false);

        f.debug_struct("IdentityManager")
            .field("has_cached_keypair", &has_keypair)
            .field("has_cached_identity", &has_identity)
            .finish_non_exhaustive()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new_manager_has_no_identity() {
        let manager = IdentityManager::new(MockStorage::new());
        assert!(!manager.has_identity().unwrap());
    }

    #[test]
    fn create_identity_stores_and_caches() {
        let manager = IdentityManager::new(MockStorage::new());
        let identity = manager.create_identity().unwrap();

        assert!(identity.npub.starts_with("npub1"));
        assert_eq!(identity.pubkey_hex.len(), 64);
        assert!(manager.has_identity().unwrap());
    }

    #[test]
    fn create_identity_fails_if_exists() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let result = manager.create_identity();
        assert!(matches!(result, Err(IdentityError::IdentityExists)));
    }

    #[test]
    fn import_from_nsec_works() {
        let manager1 = IdentityManager::new(MockStorage::new());
        let identity1 = manager1.create_identity().unwrap();
        let nsec = manager1.export_nsec().unwrap();

        let manager2 = IdentityManager::new(MockStorage::new());
        let identity2 = manager2.import_from_nsec(&nsec).unwrap();

        assert_eq!(identity1.pubkey_hex, identity2.pubkey_hex);
    }

    #[test]
    fn import_fails_if_exists() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let other = IdentityKeypair::generate();
        let nsec = other.export_nsec().unwrap();

        let result = manager.import_from_nsec(&nsec);
        assert!(matches!(result, Err(IdentityError::IdentityExists)));
    }

    #[test]
    fn import_fails_with_invalid_nsec() {
        let manager = IdentityManager::new(MockStorage::new());

        assert!(manager.import_from_nsec("invalid").is_err());
        assert!(manager.import_from_nsec("nsec1invalid").is_err());
    }

    #[test]
    fn get_identity_returns_none_if_not_exists() {
        let manager = IdentityManager::new(MockStorage::new());
        assert!(manager.get_identity().unwrap().is_none());
    }

    #[test]
    fn get_identity_loads_from_storage() {
        let storage = MockStorage::new();

        // Create identity with first manager
        let manager1 = IdentityManager::new(storage);
        let identity1 = manager1.create_identity().unwrap();

        // Simulate loading with "new" manager (reusing same storage)
        manager1.clear_cache().unwrap();
        let identity2 = manager1.get_identity().unwrap().unwrap();

        assert_eq!(identity1.pubkey_hex, identity2.pubkey_hex);
    }

    #[test]
    fn pubkey_hex_works() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let pubkey = manager.pubkey_hex().unwrap();
        assert_eq!(pubkey.len(), 64);
    }

    #[test]
    fn pubkey_hex_fails_without_identity() {
        let manager = IdentityManager::new(MockStorage::new());
        assert!(matches!(
            manager.pubkey_hex(),
            Err(IdentityError::NoIdentity)
        ));
    }

    #[test]
    fn sign_works() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let hash = [0x42u8; 32];
        let sig = manager.sign(&hash).unwrap();

        assert_eq!(sig.len(), 128);
    }

    #[test]
    fn sign_fails_without_identity() {
        let manager = IdentityManager::new(MockStorage::new());

        let hash = [0x42u8; 32];
        assert!(matches!(
            manager.sign(&hash),
            Err(IdentityError::NoIdentity)
        ));
    }

    #[test]
    fn delete_identity_clears_storage_and_cache() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();
        assert!(manager.has_identity().unwrap());

        manager.delete_identity().unwrap();
        assert!(!manager.has_identity().unwrap());
        assert!(manager.get_identity().unwrap().is_none());
    }

    #[test]
    fn clear_cache_forces_reload() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        // Get identity (should be cached)
        let _ = manager.get_identity().unwrap();

        // Clear cache
        manager.clear_cache().unwrap();

        // Should reload from storage
        let identity = manager.get_identity().unwrap().unwrap();
        assert!(identity.npub.starts_with("npub1"));
    }

    #[test]
    fn debug_does_not_leak_secrets() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let debug = format!("{manager:?}");
        assert!(debug.contains("IdentityManager"));
        assert!(debug.contains("has_cached_keypair"));
        // Should not contain actual key material
        assert!(debug.len() < 200);
    }

    #[test]
    fn export_nsec_fails_without_identity() {
        let manager = IdentityManager::new(MockStorage::new());
        assert!(matches!(
            manager.export_nsec(),
            Err(IdentityError::NoIdentity)
        ));
    }

    #[test]
    fn export_nsec_is_consistent() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let nsec1 = manager.export_nsec().unwrap();
        let nsec2 = manager.export_nsec().unwrap();

        assert_eq!(nsec1, nsec2);
    }

    #[test]
    fn get_secret_bytes_returns_zeroizing() {
        let manager = IdentityManager::new(MockStorage::new());
        manager.create_identity().unwrap();

        let secret = manager.get_secret_bytes().unwrap();
        assert_eq!(secret.len(), 32);
        // Zeroizing wrapper ensures automatic cleanup on drop
    }

    #[test]
    fn store_secret_bytes_validates_length() {
        let manager = IdentityManager::new(MockStorage::new());

        // Too short
        let result = manager.store_secret_bytes(&[0u8; 16]);
        assert!(matches!(result, Err(IdentityError::Storage(_))));

        // Too long
        let result = manager.store_secret_bytes(&[0u8; 64]);
        assert!(matches!(result, Err(IdentityError::Storage(_))));
    }

    #[test]
    fn store_secret_bytes_validates_content() {
        let manager = IdentityManager::new(MockStorage::new());

        // All zeros is invalid for secp256k1
        let result = manager.store_secret_bytes(&[0u8; 32]);
        assert!(result.is_err());
    }

    #[test]
    fn manager_is_send_and_sync() {
        // Compile-time assertion that IdentityManager is thread-safe
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<IdentityManager<MockStorage>>();
    }

    #[test]
    fn concurrent_read_access() {
        use std::sync::Arc;
        use std::thread;

        let manager = Arc::new(IdentityManager::new(MockStorage::new()));
        manager.create_identity().unwrap();

        let mut handles = vec![];

        // Spawn multiple threads that read the identity concurrently
        for _ in 0..10 {
            let manager_clone = Arc::clone(&manager);
            handles.push(thread::spawn(move || {
                let identity = manager_clone.get_identity().unwrap().unwrap();
                assert!(identity.npub.starts_with("npub1"));
                let pubkey = manager_clone.pubkey_hex().unwrap();
                assert_eq!(pubkey.len(), 64);
            }));
        }

        // Wait for all threads to complete
        for handle in handles {
            handle.join().unwrap();
        }
    }
}
