// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `lock`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `InMemoryStorage`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `delete`, `exists`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `retrieve`, `store`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CircleManagerFfi>>
abstract class CircleManagerFfi implements RustOpaqueInterface {
  /// Accepts an invitation to join a circle.
  Future<CircleWithMembersFfi> acceptInvitation({
    required List<int> mlsGroupId,
  });

  /// Adds members to a circle.
  ///
  /// Returns the update result with evolution and welcome events.
  Future<UpdateGroupResultFfi> addMembers({
    required List<int> mlsGroupId,
    required List<String> keyPackagesJson,
  });

  /// Creates a new circle.
  ///
  /// Returns the created circle and welcome events that should be
  /// gift-wrapped and sent to the invited members.
  Future<CircleCreationResultFfi> createCircle({
    required String creatorPubkey,
    required List<String> memberKeyPackagesJson,
    required String name,
    String? description,
    required String circleType,
    required List<String> relays,
  });

  /// Creates a key package for publishing.
  ///
  /// Returns the data needed to build and sign a kind 443 event.
  Future<KeyPackageBundleFfi> createKeyPackage({
    required String identityPubkey,
    required List<String> relays,
  });

  /// Declines an invitation to join a circle.
  Future<void> declineInvitation({required List<int> mlsGroupId});

  /// Deletes a contact.
  Future<void> deleteContact({required String pubkey});

  /// Finalizes a pending commit after publishing evolution events.
  ///
  /// Call this after successfully publishing the evolution event.
  Future<void> finalizePendingCommit({required List<int> mlsGroupId});

  /// Gets all contacts.
  List<ContactFfi> getAllContacts();

  /// Gets a circle by its MLS group ID.
  CircleWithMembersFfi? getCircle({required List<int> mlsGroupId});

  /// Gets all circles.
  List<CircleWithMembersFfi> getCircles();

  /// Gets a contact by pubkey.
  ContactFfi? getContact({required String pubkey});

  /// Gets members of a circle with resolved contact info.
  List<CircleMemberFfi> getMembers({required List<int> mlsGroupId});

  /// Gets all pending invitations.
  List<InvitationFfi> getPendingInvitations();

  /// Gets visible circles (excludes declined invitations).
  List<CircleWithMembersFfi> getVisibleCircles();

  /// Leaves a circle.
  ///
  /// Returns the update result with evolution events to publish.
  Future<UpdateGroupResultFfi> leaveCircle({required List<int> mlsGroupId});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new circle manager.
  ///
  /// Initializes both MLS storage and circle metadata database
  /// at the given data directory.
  static Future<CircleManagerFfi> newInstance({required String dataDir}) =>
      RustLib.instance.api.crateApiCircleManagerFfiNew(dataDir: dataDir);

  /// Processes an incoming invitation (Welcome event).
  ///
  /// Call this when a kind 444 Welcome event is received via gift-wrap.
  Future<InvitationFfi> processInvitation({
    required String wrapperEventId,
    required String rumorEventJson,
    required String circleName,
    required String inviterPubkey,
  });

  /// Removes members from a circle.
  ///
  /// Returns the update result with evolution events.
  Future<UpdateGroupResultFfi> removeMembers({
    required List<int> mlsGroupId,
    required List<String> memberPubkeys,
  });

  /// Sets or updates a contact.
  ///
  /// Contact information is stored locally only and never synced to relays.
  Future<ContactFfi> setContact({
    required String pubkey,
    String? displayName,
    String? avatarPath,
    String? notes,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HavenCore>>
abstract class HavenCore implements RustOpaqueInterface {
  static Future<HavenCore> default_() =>
      RustLib.instance.api.crateApiHavenCoreDefault();

  /// Gets the current location settings.
  LocationSettings getLocationSettings();

  /// Initializes the core.
  Future<void> initialize();

  /// Returns whether the core has been initialized.
  bool isInitialized();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `HavenCore` instance.
  static Future<HavenCore> newInstance() =>
      RustLib.instance.api.crateApiHavenCoreNew();

  /// Updates the location settings.
  void setLocationSettings({required LocationSettings settings});

  /// Processes raw location data and returns an obfuscated `LocationMessage`.
  LocationMessage updateLocation({
    required double latitude,
    required double longitude,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationEventService>>
abstract class LocationEventService implements RustOpaqueInterface {
  /// Creates an unsigned location event (kind 30078).
  ///
  /// This is the inner event that gets encrypted before being wrapped
  /// in a kind 445 group message.
  UnsignedLocationEventFfi createUnsignedEvent({
    required LocationMessage location,
  });

  static Future<LocationEventService> default_() =>
      RustLib.instance.api.crateApiLocationEventServiceDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `LocationEventService`.
  static Future<LocationEventService> newInstance() =>
      RustLib.instance.api.crateApiLocationEventServiceNew();

  /// Verifies the signature of a signed event.
  ///
  /// Returns `true` if the signature is valid, `false` otherwise.
  bool verifySignature({required SignedLocationEventFfi event});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationMessage>>
abstract class LocationMessage implements RustOpaqueInterface {
  /// Gets the expiration time as Unix timestamp (seconds since epoch).
  PlatformInt64 expiresAt();

  /// Gets the geohash representation.
  String geohash();

  /// Checks if the location has expired.
  bool isExpired();

  /// Gets the obfuscated latitude.
  double latitude();

  /// Gets the obfuscated longitude.
  double longitude();

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the timestamp as Unix timestamp (seconds since epoch).
  PlatformInt64 timestamp();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationPrecision>>
abstract class LocationPrecision implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationSettings>>
abstract class LocationSettings implements RustOpaqueInterface {
  /// Gets whether to include geohash in events.
  bool includeGeohashInEvents();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates new location settings.
  static Future<LocationSettings> newInstance({
    required LocationPrecision precision,
    required int updateIntervalMinutes,
    required bool includeGeohashInEvents,
  }) => RustLib.instance.api.crateApiLocationSettingsNew(
    precision: precision,
    updateIntervalMinutes: updateIntervalMinutes,
    includeGeohashInEvents: includeGeohashInEvents,
  );

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the update interval in minutes.
  int updateIntervalMinutes();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NostrIdentityManager>>
abstract class NostrIdentityManager implements RustOpaqueInterface {
  /// Clears the in-memory cache.
  ///
  /// Call this when the app goes to background.
  Future<void> clearCache();

  /// Creates a new random identity.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> createIdentity();

  static Future<NostrIdentityManager> default_() =>
      RustLib.instance.api.crateApiNostrIdentityManagerDefault();

  /// Deletes the identity.
  Future<void> deleteIdentity();

  /// Exports the identity as nsec for backup.
  ///
  /// # Security Warning
  ///
  /// This exposes the secret key. Only use for user-initiated backup.
  Future<String> exportNsec();

  /// Gets the current public identity.
  PublicIdentity? getIdentity();

  /// Gets the secret bytes for persistence in Flutter secure storage.
  ///
  /// # Security Warning
  ///
  /// Handle these bytes with extreme care. They should only be stored
  /// in platform secure storage (iOS Keychain, Android Keystore, etc.).
  /// The bytes are automatically zeroized in Rust memory after this call.
  Future<Uint8List> getSecretBytes();

  /// Checks if an identity is loaded.
  bool hasIdentity();

  /// Imports an identity from an nsec string.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> importFromNsec({required String nsec});

  /// Loads an identity from raw secret bytes (retrieved from Flutter secure storage).
  ///
  /// Call this on app startup if you have persisted secret bytes.
  Future<PublicIdentity> loadFromBytes({required List<int> secretBytes});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new identity manager.
  static Future<NostrIdentityManager> newInstance() =>
      RustLib.instance.api.crateApiNostrIdentityManagerNew();

  /// Gets the public key as hex string (for MDK operations).
  String pubkeyHex();

  /// Signs a 32-byte message hash.
  ///
  /// Returns the signature as a 128-character hex string.
  Future<String> sign({required List<int> messageHash});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayManagerFfi>>
abstract class RelayManagerFfi implements RustOpaqueInterface {
  /// Gets the connection status of all relays.
  Future<List<RelayConnectionStatusFfi>> getRelayStatus();

  /// Returns whether Tor is fully bootstrapped and ready.
  Future<bool> isReady();

  /// Creates a new relay manager and begins Tor bootstrap.
  ///
  /// The manager will start bootstrapping the embedded Tor client.
  /// Use `is_ready()` or `tor_status()` to check bootstrap progress.
  static Future<RelayManagerFfi> newInstance({required String dataDir}) =>
      RustLib.instance.api.crateApiRelayManagerFfiNewInstance(dataDir: dataDir);

  /// Publishes a signed event to the specified relays.
  ///
  /// The event will be published through Tor to all specified relays.
  ///
  /// # Arguments
  ///
  /// * `event_json` - JSON-serialized signed Nostr event
  /// * `relays` - List of relay URLs (must be wss://)
  /// * `is_identity_operation` - If true, uses identity circuit; if false,
  ///   requires `nostr_group_id` for group-specific circuit
  /// * `nostr_group_id` - 32-byte group ID for circuit isolation (required
  ///   if `is_identity_operation` is false)
  Future<PublishResultFfi> publishEvent({
    required String eventJson,
    required List<String> relays,
    required bool isIdentityOperation,
    Uint8List? nostrGroupId,
  });

  /// Disconnects from all relays and shuts down Tor.
  Future<void> shutdown();

  /// Returns the current Tor bootstrap status.
  Future<TorStatusFfi> torStatus();
}

/// Result of circle creation (FFI-friendly).
class CircleCreationResultFfi {
  /// The created circle.
  final CircleFfi circle;

  /// Welcome events (unsigned) to gift-wrap and send to members.
  /// Each is a kind 444 event that must remain unsigned per Marmot protocol.
  final List<UnsignedEventFfi> welcomeEvents;

  const CircleCreationResultFfi({
    required this.circle,
    required this.welcomeEvents,
  });

  @override
  int get hashCode => circle.hashCode ^ welcomeEvents.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleCreationResultFfi &&
          runtimeType == other.runtimeType &&
          circle == other.circle &&
          welcomeEvents == other.welcomeEvents;
}

/// Circle information (FFI-friendly).
///
/// Represents a location sharing circle (group of people).
class CircleFfi {
  /// MLS group ID (opaque bytes, used for API calls).
  final Uint8List mlsGroupId;

  /// Nostr group ID (32 bytes, used in h-tags for relay routing).
  final Uint8List nostrGroupId;

  /// User-facing display name (local only).
  final String displayName;

  /// Circle type: "location_sharing" or "direct_share".
  final String circleType;

  /// Relay URLs for this circle's messages.
  final List<String> relays;

  /// When the circle was created (Unix timestamp).
  final PlatformInt64 createdAt;

  /// When the circle was last updated (Unix timestamp).
  final PlatformInt64 updatedAt;

  const CircleFfi({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.displayName,
    required this.circleType,
    required this.relays,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      displayName.hashCode ^
      circleType.hashCode ^
      relays.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleFfi &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          displayName == other.displayName &&
          circleType == other.circleType &&
          relays == other.relays &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Circle member with resolved local contact info (FFI-friendly).
class CircleMemberFfi {
  /// Nostr public key (hex) - always available.
  final String pubkey;

  /// Display name from local Contact, if set.
  final String? displayName;

  /// Avatar path from local Contact, if set.
  final String? avatarPath;

  /// Whether this member is a group admin.
  final bool isAdmin;

  const CircleMemberFfi({
    required this.pubkey,
    this.displayName,
    this.avatarPath,
    required this.isAdmin,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^
      displayName.hashCode ^
      avatarPath.hashCode ^
      isAdmin.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleMemberFfi &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          displayName == other.displayName &&
          avatarPath == other.avatarPath &&
          isAdmin == other.isAdmin;
}

/// Circle with its membership and member list (FFI-friendly).
class CircleWithMembersFfi {
  /// The circle.
  final CircleFfi circle;

  /// User's membership status: "pending", "accepted", or "declined".
  final String membershipStatus;

  /// Public key of who invited us (if known).
  final String? inviterPubkey;

  /// Members with resolved contact info.
  final List<CircleMemberFfi> members;

  const CircleWithMembersFfi({
    required this.circle,
    required this.membershipStatus,
    this.inviterPubkey,
    required this.members,
  });

  @override
  int get hashCode =>
      circle.hashCode ^
      membershipStatus.hashCode ^
      inviterPubkey.hashCode ^
      members.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleWithMembersFfi &&
          runtimeType == other.runtimeType &&
          circle == other.circle &&
          membershipStatus == other.membershipStatus &&
          inviterPubkey == other.inviterPubkey &&
          members == other.members;
}

/// Local contact information (FFI-friendly).
///
/// **Privacy Note**: This data is stored only on the user's device,
/// never synced to Nostr relays. Each user assigns their own names
/// and avatars to contacts (like phone contacts).
class ContactFfi {
  /// Nostr public key (hex) - the ONLY identifier visible to relays.
  final String pubkey;

  /// Locally assigned display name.
  final String? displayName;

  /// Local file path to avatar image.
  final String? avatarPath;

  /// Optional notes about this contact.
  final String? notes;

  /// When this contact was created (Unix timestamp).
  final PlatformInt64 createdAt;

  /// When this contact was last updated (Unix timestamp).
  final PlatformInt64 updatedAt;

  const ContactFfi({
    required this.pubkey,
    this.displayName,
    this.avatarPath,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^
      displayName.hashCode ^
      avatarPath.hashCode ^
      notes.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactFfi &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          displayName == other.displayName &&
          avatarPath == other.avatarPath &&
          notes == other.notes &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Pending invitation to join a circle (FFI-friendly).
class InvitationFfi {
  /// MLS group ID.
  final Uint8List mlsGroupId;

  /// Circle name.
  final String circleName;

  /// Public key (hex) of who invited us.
  final String inviterPubkey;

  /// Number of members in the circle.
  final int memberCount;

  /// When we were invited (Unix timestamp).
  final PlatformInt64 invitedAt;

  const InvitationFfi({
    required this.mlsGroupId,
    required this.circleName,
    required this.inviterPubkey,
    required this.memberCount,
    required this.invitedAt,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      circleName.hashCode ^
      inviterPubkey.hashCode ^
      memberCount.hashCode ^
      invitedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InvitationFfi &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          circleName == other.circleName &&
          inviterPubkey == other.inviterPubkey &&
          memberCount == other.memberCount &&
          invitedAt == other.invitedAt;
}

/// Key package bundle for publishing (FFI-friendly).
///
/// Contains the data needed to build a kind 443 Nostr event.
class KeyPackageBundleFfi {
  /// Hex-encoded serialized key package (event content).
  final String content;

  /// Tags to include in the event.
  final List<List<String>> tags;

  /// Relay URLs where this key package will be published.
  final List<String> relays;

  const KeyPackageBundleFfi({
    required this.content,
    required this.tags,
    required this.relays,
  });

  @override
  int get hashCode => content.hashCode ^ tags.hashCode ^ relays.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageBundleFfi &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          tags == other.tags &&
          relays == other.relays;
}

/// Public identity information (FFI-friendly).
///
/// Contains only public data that can be safely stored and shared.
class PublicIdentity {
  /// Public key as 64-character hex string.
  final String pubkeyHex;

  /// Public key in NIP-19 bech32 format (npub1...).
  final String npub;

  /// When this identity was created (Unix timestamp).
  final PlatformInt64 createdAt;

  const PublicIdentity({
    required this.pubkeyHex,
    required this.npub,
    required this.createdAt,
  });

  @override
  int get hashCode => pubkeyHex.hashCode ^ npub.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicIdentity &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          npub == other.npub &&
          createdAt == other.createdAt;
}

/// Result of publishing an event (FFI-friendly).
class PublishResultFfi {
  /// The event ID that was published (64-char hex).
  final String eventId;

  /// Relays that accepted the event.
  final List<String> acceptedBy;

  /// Relays that rejected the event (URL, reason pairs).
  final List<RelayRejectionFfi> rejectedBy;

  /// Relays that failed to respond.
  final List<String> failed;

  /// Whether at least one relay accepted the event.
  final bool isSuccess;

  const PublishResultFfi({
    required this.eventId,
    required this.acceptedBy,
    required this.rejectedBy,
    required this.failed,
    required this.isSuccess,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      acceptedBy.hashCode ^
      rejectedBy.hashCode ^
      failed.hashCode ^
      isSuccess.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublishResultFfi &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          acceptedBy == other.acceptedBy &&
          rejectedBy == other.rejectedBy &&
          failed == other.failed &&
          isSuccess == other.isSuccess;
}

/// Relay connection status (FFI-friendly).
class RelayConnectionStatusFfi {
  /// The relay URL.
  final String url;

  /// Connection status: "connected", "disconnected", "connecting", or "failed".
  final String status;

  /// Last time the relay was seen (Unix timestamp), if known.
  final PlatformInt64? lastSeen;

  const RelayConnectionStatusFfi({
    required this.url,
    required this.status,
    this.lastSeen,
  });

  @override
  int get hashCode => url.hashCode ^ status.hashCode ^ lastSeen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RelayConnectionStatusFfi &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          status == other.status &&
          lastSeen == other.lastSeen;
}

/// Relay rejection info (FFI-friendly).
class RelayRejectionFfi {
  /// Relay URL that rejected.
  final String url;

  /// Rejection reason.
  final String reason;

  const RelayRejectionFfi({required this.url, required this.reason});

  @override
  int get hashCode => url.hashCode ^ reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RelayRejectionFfi &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          reason == other.reason;
}

/// Generic signed event for FFI use.
class SignedEventFfi {
  /// Event ID (hex).
  final String id;

  /// Event kind.
  final int kind;

  /// Event content.
  final String content;

  /// Event tags.
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Public key (hex) of the event creator.
  final String pubkey;

  /// Signature (hex).
  final String sig;

  const SignedEventFfi({
    required this.id,
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
    required this.pubkey,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      kind.hashCode ^
      content.hashCode ^
      tags.hashCode ^
      createdAt.hashCode ^
      pubkey.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignedEventFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt &&
          pubkey == other.pubkey &&
          sig == other.sig;
}

/// Signed location event (FFI wrapper for outer event kind 445).
///
/// This is the outer event ready for relay transmission.
/// Contains encrypted content signed with an ephemeral keypair.
class SignedLocationEventFfi {
  /// Event ID (SHA256 hash, 64 hex chars).
  final String id;

  /// Ephemeral public key (64 hex chars).
  final String pubkey;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Event kind (445 for Marmot group messages).
  final int kind;

  /// Event tags: `[["h", group_id], ["expiration", ts], ...]`.
  final List<List<String>> tags;

  /// NIP-44 encrypted content (base64).
  final String content;

  /// Schnorr signature (128 hex chars).
  final String sig;

  const SignedLocationEventFfi({
    required this.id,
    required this.pubkey,
    required this.createdAt,
    required this.kind,
    required this.tags,
    required this.content,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      pubkey.hashCode ^
      createdAt.hashCode ^
      kind.hashCode ^
      tags.hashCode ^
      content.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          kind == other.kind &&
          tags == other.tags &&
          content == other.content &&
          sig == other.sig;
}

/// Tor bootstrap status (FFI-friendly).
class TorStatusFfi {
  /// Bootstrap progress percentage (0-100).
  final int progress;

  /// Whether Tor is fully bootstrapped and ready.
  final bool isReady;

  /// Current bootstrap phase description.
  final String phase;

  const TorStatusFfi({
    required this.progress,
    required this.isReady,
    required this.phase,
  });

  @override
  int get hashCode => progress.hashCode ^ isReady.hashCode ^ phase.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TorStatusFfi &&
          runtimeType == other.runtimeType &&
          progress == other.progress &&
          isReady == other.isReady &&
          phase == other.phase;
}

/// Unsigned Nostr event (FFI-friendly).
///
/// Generic unsigned event for FFI use.
class UnsignedEventFfi {
  /// Event kind.
  final int kind;

  /// Event content.
  final String content;

  /// Event tags.
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Public key (hex) of the event creator (may be empty for unsigned).
  final String pubkey;

  const UnsignedEventFfi({
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
    required this.pubkey,
  });

  @override
  int get hashCode =>
      kind.hashCode ^
      content.hashCode ^
      tags.hashCode ^
      createdAt.hashCode ^
      pubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedEventFfi &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt &&
          pubkey == other.pubkey;
}

/// Unsigned location event (FFI wrapper for inner event kind 30078).
///
/// This is the inner event containing location data before encryption.
/// It is wrapped in a kind 445 group message for transmission.
class UnsignedLocationEventFfi {
  /// Event kind (30078 for location data).
  final int kind;

  /// JSON-serialized location data.
  final String content;

  /// Event tags (typically empty for inner events).
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  const UnsignedLocationEventFfi({
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
  });

  @override
  int get hashCode =>
      kind.hashCode ^ content.hashCode ^ tags.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt;
}

/// Update group result (FFI-friendly).
///
/// Returned after add/remove members or leave operations.
class UpdateGroupResultFfi {
  /// Evolution event (kind 445) to publish to the group relays.
  final SignedEventFfi evolutionEvent;

  /// Welcome events (kind 444) for newly added members (if any).
  final List<UnsignedEventFfi> welcomeEvents;

  const UpdateGroupResultFfi({
    required this.evolutionEvent,
    required this.welcomeEvents,
  });

  @override
  int get hashCode => evolutionEvent.hashCode ^ welcomeEvents.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateGroupResultFfi &&
          runtimeType == other.runtimeType &&
          evolutionEvent == other.evolutionEvent &&
          welcomeEvents == other.welcomeEvents;
}
