// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `InMemoryStorage`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `delete`, `exists`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `retrieve`, `store`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HavenCore>>
abstract class HavenCore implements RustOpaqueInterface {
  static Future<HavenCore> default_() =>
      RustLib.instance.api.crateApiHavenCoreDefault();

  /// Gets the current location settings.
  LocationSettings getLocationSettings();

  /// Initializes the core.
  Future<void> initialize();

  /// Returns whether the core has been initialized.
  bool isInitialized();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `HavenCore` instance.
  static Future<HavenCore> newInstance() =>
      RustLib.instance.api.crateApiHavenCoreNew();

  /// Updates the location settings.
  void setLocationSettings({required LocationSettings settings});

  /// Processes raw location data and returns an obfuscated `LocationMessage`.
  LocationMessage updateLocation({
    required double latitude,
    required double longitude,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationEventService>>
abstract class LocationEventService implements RustOpaqueInterface {
  /// Creates an unsigned location event (kind 30078).
  ///
  /// This is the inner event that gets encrypted before being wrapped
  /// in a kind 445 group message.
  UnsignedLocationEventFfi createUnsignedEvent({
    required LocationMessage location,
  });

  static Future<LocationEventService> default_() =>
      RustLib.instance.api.crateApiLocationEventServiceDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `LocationEventService`.
  static Future<LocationEventService> newInstance() =>
      RustLib.instance.api.crateApiLocationEventServiceNew();

  /// Verifies the signature of a signed event.
  ///
  /// Returns `true` if the signature is valid, `false` otherwise.
  bool verifySignature({required SignedLocationEventFfi event});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationMessage>>
abstract class LocationMessage implements RustOpaqueInterface {
  /// Gets the expiration time as Unix timestamp (seconds since epoch).
  PlatformInt64 expiresAt();

  /// Gets the geohash representation.
  String geohash();

  /// Checks if the location has expired.
  bool isExpired();

  /// Gets the obfuscated latitude.
  double latitude();

  /// Gets the obfuscated longitude.
  double longitude();

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the timestamp as Unix timestamp (seconds since epoch).
  PlatformInt64 timestamp();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationPrecision>>
abstract class LocationPrecision implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationSettings>>
abstract class LocationSettings implements RustOpaqueInterface {
  /// Gets whether to include geohash in events.
  bool includeGeohashInEvents();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates new location settings.
  static Future<LocationSettings> newInstance({
    required LocationPrecision precision,
    required int updateIntervalMinutes,
    required bool includeGeohashInEvents,
  }) => RustLib.instance.api.crateApiLocationSettingsNew(
    precision: precision,
    updateIntervalMinutes: updateIntervalMinutes,
    includeGeohashInEvents: includeGeohashInEvents,
  );

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the update interval in minutes.
  int updateIntervalMinutes();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NostrIdentityManager>>
abstract class NostrIdentityManager implements RustOpaqueInterface {
  /// Clears the in-memory cache.
  ///
  /// Call this when the app goes to background.
  Future<void> clearCache();

  /// Creates a new random identity.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> createIdentity();

  static Future<NostrIdentityManager> default_() =>
      RustLib.instance.api.crateApiNostrIdentityManagerDefault();

  /// Deletes the identity.
  Future<void> deleteIdentity();

  /// Exports the identity as nsec for backup.
  ///
  /// # Security Warning
  ///
  /// This exposes the secret key. Only use for user-initiated backup.
  Future<String> exportNsec();

  /// Gets the current public identity.
  PublicIdentity? getIdentity();

  /// Gets the secret bytes for persistence in Flutter secure storage.
  ///
  /// # Security Warning
  ///
  /// Handle these bytes with extreme care. They should only be stored
  /// in platform secure storage (iOS Keychain, Android Keystore, etc.).
  /// The bytes are automatically zeroized in Rust memory after this call.
  Future<Uint8List> getSecretBytes();

  /// Checks if an identity is loaded.
  bool hasIdentity();

  /// Imports an identity from an nsec string.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> importFromNsec({required String nsec});

  /// Loads an identity from raw secret bytes (retrieved from Flutter secure storage).
  ///
  /// Call this on app startup if you have persisted secret bytes.
  Future<PublicIdentity> loadFromBytes({required List<int> secretBytes});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new identity manager.
  static Future<NostrIdentityManager> newInstance() =>
      RustLib.instance.api.crateApiNostrIdentityManagerNew();

  /// Gets the public key as hex string (for MDK operations).
  String pubkeyHex();

  /// Signs a 32-byte message hash.
  ///
  /// Returns the signature as a 128-character hex string.
  Future<String> sign({required List<int> messageHash});
}

/// Public identity information (FFI-friendly).
///
/// Contains only public data that can be safely stored and shared.
class PublicIdentity {
  /// Public key as 64-character hex string.
  final String pubkeyHex;

  /// Public key in NIP-19 bech32 format (npub1...).
  final String npub;

  /// When this identity was created (Unix timestamp).
  final PlatformInt64 createdAt;

  const PublicIdentity({
    required this.pubkeyHex,
    required this.npub,
    required this.createdAt,
  });

  @override
  int get hashCode => pubkeyHex.hashCode ^ npub.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicIdentity &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          npub == other.npub &&
          createdAt == other.createdAt;
}

/// Signed location event (FFI wrapper for outer event kind 445).
///
/// This is the outer event ready for relay transmission.
/// Contains encrypted content signed with an ephemeral keypair.
class SignedLocationEventFfi {
  /// Event ID (SHA256 hash, 64 hex chars).
  final String id;

  /// Ephemeral public key (64 hex chars).
  final String pubkey;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Event kind (445 for Marmot group messages).
  final int kind;

  /// Event tags: `[["h", group_id], ["expiration", ts], ...]`.
  final List<List<String>> tags;

  /// NIP-44 encrypted content (base64).
  final String content;

  /// Schnorr signature (128 hex chars).
  final String sig;

  const SignedLocationEventFfi({
    required this.id,
    required this.pubkey,
    required this.createdAt,
    required this.kind,
    required this.tags,
    required this.content,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      pubkey.hashCode ^
      createdAt.hashCode ^
      kind.hashCode ^
      tags.hashCode ^
      content.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          kind == other.kind &&
          tags == other.tags &&
          content == other.content &&
          sig == other.sig;
}

/// Unsigned location event (FFI wrapper for inner event kind 30078).
///
/// This is the inner event containing location data before encryption.
/// It is wrapped in a kind 445 group message for transmission.
class UnsignedLocationEventFfi {
  /// Event kind (30078 for location data).
  final int kind;

  /// JSON-serialized location data.
  final String content;

  /// Event tags (typically empty for inner events).
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  const UnsignedLocationEventFfi({
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
  });

  @override
  int get hashCode =>
      kind.hashCode ^ content.hashCode ^ tags.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt;
}
