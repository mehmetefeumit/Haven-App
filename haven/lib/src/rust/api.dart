// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `InMemoryStorage`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `delete`, `exists`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `retrieve`, `store`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CircleManagerFfi>>
abstract class CircleManagerFfi implements RustOpaqueInterface {
  /// Accepts an invitation to join a circle.
  Future<CircleWithMembersFfi> acceptInvitation({
    required List<int> mlsGroupId,
  });

  /// Adds members to a circle.
  ///
  /// Returns the update result with evolution and welcome events.
  Future<UpdateGroupResultFfi> addMembers({
    required List<int> mlsGroupId,
    required List<String> keyPackagesJson,
  });

  /// Creates a new circle with gift-wrapped Welcome events.
  ///
  /// Returns the created circle and gift-wrapped Welcome events ready
  /// to publish to the invited members' inbox relays.
  ///
  /// # Arguments
  ///
  /// * `identity_secret_bytes` - The creator's identity secret bytes (32 bytes,
  ///   from `NostrIdentityManager.get_secret_bytes()`)
  /// * `members` - Key packages and inbox relays for each member
  /// * `name` - Circle name
  /// * `description` - Optional circle description
  /// * `circle_type` - Circle type: "location_sharing" or "direct_share"
  /// * `relays` - Relay URLs for the circle's messages
  ///
  /// # Security
  ///
  /// The Welcome events are gift-wrapped per NIP-59, hiding the sender's
  /// identity behind an ephemeral key. Each Welcome uses a fresh ephemeral
  /// keypair and randomized timestamp.
  Future<CircleCreationResultFfi> createCircle({
    required List<int> identitySecretBytes,
    required List<MemberKeyPackageFfi> members,
    required String name,
    String? description,
    required String circleType,
    required List<String> relays,
  });

  /// Creates a key package for publishing.
  ///
  /// Returns the data needed to build and sign a kind 443 event.
  Future<KeyPackageBundleFfi> createKeyPackage({
    required String identityPubkey,
    required List<String> relays,
  });

  /// Declines an invitation to join a circle.
  Future<void> declineInvitation({required List<int> mlsGroupId});

  /// Decrypts a received location event.
  ///
  /// Processes a kind 445 event through MLS decryption and extracts the
  /// location data. Returns `None` for non-location messages (group updates,
  /// unprocessable messages).
  ///
  /// # Arguments
  ///
  /// * `event_json` - JSON-serialized kind 445 event
  Future<DecryptedLocationFfi?> decryptLocation({required String eventJson});

  /// Deletes a contact.
  Future<void> deleteContact({required String pubkey});

  /// Encrypts a location for a circle.
  ///
  /// Creates an MLS-encrypted kind 445 event containing the location data.
  /// The returned event is ready to publish to the circle's relays.
  ///
  /// # Arguments
  ///
  /// * `mls_group_id` - The circle's MLS group ID
  /// * `sender_pubkey_hex` - The sender's Nostr public key (hex)
  /// * `latitude` - GPS latitude
  /// * `longitude` - GPS longitude
  Future<EncryptedLocationFfi> encryptLocation({
    required List<int> mlsGroupId,
    required String senderPubkeyHex,
    required double latitude,
    required double longitude,
  });

  /// Finalizes a pending commit after publishing evolution events.
  ///
  /// Call this after successfully publishing the evolution event.
  Future<void> finalizePendingCommit({required List<int> mlsGroupId});

  /// Gets all contacts.
  Future<List<ContactFfi>> getAllContacts();

  /// Gets a circle by its MLS group ID.
  Future<CircleWithMembersFfi?> getCircle({required List<int> mlsGroupId});

  /// Gets all circles.
  Future<List<CircleWithMembersFfi>> getCircles();

  /// Gets a contact by pubkey.
  Future<ContactFfi?> getContact({required String pubkey});

  /// Gets members of a circle with resolved contact info.
  Future<List<CircleMemberFfi>> getMembers({required List<int> mlsGroupId});

  /// Gets all pending invitations.
  Future<List<InvitationFfi>> getPendingInvitations();

  /// Gets visible circles (excludes declined invitations).
  Future<List<CircleWithMembersFfi>> getVisibleCircles();

  /// Leaves a circle.
  ///
  /// Returns the update result with evolution events to publish.
  Future<UpdateGroupResultFfi> leaveCircle({required List<int> mlsGroupId});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new circle manager.
  ///
  /// Initializes both MLS storage and circle metadata database
  /// at the given data directory.
  static Future<CircleManagerFfi> newInstance({required String dataDir}) =>
      RustLib.instance.api.crateApiCircleManagerFfiNew(dataDir: dataDir);

  /// Processes a gift-wrapped Welcome event (kind 1059).
  ///
  /// This is the high-level API for processing incoming invitations.
  /// It unwraps the gift-wrapped event, extracts the sender info,
  /// and processes the invitation.
  ///
  /// # Arguments
  ///
  /// * `identity_secret_bytes` - The recipient's identity secret bytes (32 bytes)
  /// * `gift_wrap_event_json` - The kind 1059 gift-wrapped event JSON
  /// * `circle_name` - Name of the circle (from invitation metadata)
  ///
  /// # Returns
  ///
  /// The pending invitation, which can be accepted or declined.
  Future<InvitationFfi> processGiftWrappedInvitation({
    required List<int> identitySecretBytes,
    required String giftWrapEventJson,
    required String circleName,
  });

  /// Processes an incoming invitation from already-unwrapped components.
  ///
  /// This is the low-level API that takes pre-unwrapped components.
  /// Prefer [`process_gift_wrapped_invitation`] for most use cases.
  ///
  /// # Arguments
  ///
  /// * `wrapper_event_id` - ID of the gift-wrapped event (hex)
  /// * `rumor_event_json` - The decrypted kind 444 rumor event JSON
  /// * `circle_name` - Name of the circle
  /// * `inviter_pubkey` - Public key (hex) of the inviter
  ///
  /// [`process_gift_wrapped_invitation`]: Self::process_gift_wrapped_invitation
  Future<InvitationFfi> processInvitation({
    required String wrapperEventId,
    required String rumorEventJson,
    required String circleName,
    required String inviterPubkey,
  });

  /// Removes members from a circle.
  ///
  /// Returns the update result with evolution events.
  Future<UpdateGroupResultFfi> removeMembers({
    required List<int> mlsGroupId,
    required List<String> memberPubkeys,
  });

  /// Sets or updates a contact.
  ///
  /// Contact information is stored locally only and never synced to relays.
  Future<ContactFfi> setContact({
    required String pubkey,
    String? displayName,
    String? avatarPath,
    String? notes,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HavenCore>>
abstract class HavenCore implements RustOpaqueInterface {
  static Future<HavenCore> default_() =>
      RustLib.instance.api.crateApiHavenCoreDefault();

  /// Gets the current location settings.
  LocationSettings getLocationSettings();

  /// Initializes the core.
  Future<void> initialize();

  /// Returns whether the core has been initialized.
  bool isInitialized();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `HavenCore` instance.
  static Future<HavenCore> newInstance() =>
      RustLib.instance.api.crateApiHavenCoreNew();

  /// Updates the location settings.
  void setLocationSettings({required LocationSettings settings});

  /// Processes raw location data and returns an obfuscated `LocationMessage`.
  LocationMessage updateLocation({
    required double latitude,
    required double longitude,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationEventService>>
abstract class LocationEventService implements RustOpaqueInterface {
  /// Creates an unsigned location event (kind 30078).
  ///
  /// This is the inner event that gets encrypted before being wrapped
  /// in a kind 445 group message.
  UnsignedLocationEventFfi createUnsignedEvent({
    required LocationMessage location,
  });

  static Future<LocationEventService> default_() =>
      RustLib.instance.api.crateApiLocationEventServiceDefault();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `LocationEventService`.
  static Future<LocationEventService> newInstance() =>
      RustLib.instance.api.crateApiLocationEventServiceNew();

  /// Verifies the signature of a signed event.
  ///
  /// Returns `true` if the signature is valid, `false` otherwise.
  bool verifySignature({required SignedLocationEventFfi event});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationMessage>>
abstract class LocationMessage implements RustOpaqueInterface {
  /// Gets the expiration time as Unix timestamp (seconds since epoch).
  PlatformInt64 expiresAt();

  /// Gets the geohash representation.
  String geohash();

  /// Checks if the location has expired.
  bool isExpired();

  /// Gets the obfuscated latitude.
  double latitude();

  /// Gets the obfuscated longitude.
  double longitude();

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the timestamp as Unix timestamp (seconds since epoch).
  PlatformInt64 timestamp();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationPrecision>>
abstract class LocationPrecision implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LocationSettings>>
abstract class LocationSettings implements RustOpaqueInterface {
  /// Gets whether to include geohash in events.
  bool includeGeohashInEvents();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates new location settings.
  static Future<LocationSettings> newInstance({
    required LocationPrecision precision,
    required int updateIntervalMinutes,
    required bool includeGeohashInEvents,
  }) => RustLib.instance.api.crateApiLocationSettingsNew(
    precision: precision,
    updateIntervalMinutes: updateIntervalMinutes,
    includeGeohashInEvents: includeGeohashInEvents,
  );

  /// Gets the precision level.
  LocationPrecision precision();

  /// Gets the update interval in minutes.
  int updateIntervalMinutes();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NostrIdentityManager>>
abstract class NostrIdentityManager implements RustOpaqueInterface {
  /// Clears the in-memory cache.
  ///
  /// Call this when the app goes to background.
  Future<void> clearCache();

  /// Creates a new random identity.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> createIdentity();

  static Future<NostrIdentityManager> default_() =>
      RustLib.instance.api.crateApiNostrIdentityManagerDefault();

  /// Deletes the identity.
  Future<void> deleteIdentity();

  /// Exports the identity as nsec for backup.
  ///
  /// # Security Warning
  ///
  /// This exposes the secret key. Only use for user-initiated backup.
  Future<String> exportNsec();

  /// Gets the current public identity.
  PublicIdentity? getIdentity();

  /// Gets the secret bytes for persistence in Flutter secure storage.
  ///
  /// # Security Warning
  ///
  /// Handle these bytes with extreme care. They should only be stored
  /// in platform secure storage (iOS Keychain, Android Keystore, etc.).
  /// The bytes are automatically zeroized in Rust memory after this call.
  Future<Uint8List> getSecretBytes();

  /// Checks if an identity is loaded.
  bool hasIdentity();

  /// Imports an identity from an nsec string.
  ///
  /// After calling this, use `get_secret_bytes()` to persist the secret.
  Future<PublicIdentity> importFromNsec({required String nsec});

  /// Loads an identity from raw secret bytes (retrieved from Flutter secure storage).
  ///
  /// Call this on app startup if you have persisted secret bytes.
  Future<PublicIdentity> loadFromBytes({required List<int> secretBytes});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new identity manager.
  static Future<NostrIdentityManager> newInstance() =>
      RustLib.instance.api.crateApiNostrIdentityManagerNew();

  /// Gets the public key as hex string (for MDK operations).
  String pubkeyHex();

  /// Signs a 32-byte message hash.
  ///
  /// Returns the signature as a 128-character hex string.
  Future<String> sign({required List<int> messageHash});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayManagerFfi>>
abstract class RelayManagerFfi implements RustOpaqueInterface {
  /// Fetches gift-wrapped events (kind 1059) addressed to a recipient.
  ///
  /// Queries the given relays for NIP-59 gift wrap events tagged with the
  /// recipient's public key. An optional `since` timestamp restricts results
  /// to events created after that point.
  ///
  /// # Arguments
  ///
  /// * `recipient_pubkey` - The recipient's public key (hex or npub format)
  /// * `relays` - Relay URLs to query
  /// * `since` - Optional Unix timestamp (seconds); only events after this time are returned
  ///
  /// # Returns
  ///
  /// A list of gift-wrap events serialized as JSON strings.
  Future<List<String>> fetchGiftWraps({
    required String recipientPubkey,
    required List<String> relays,
    PlatformInt64? since,
  });

  /// Fetches MLS group messages (kind 445) from relays.
  ///
  /// Queries relays for encrypted group messages using the h-tag
  /// for routing.
  ///
  /// # Arguments
  ///
  /// * `nostr_group_id` - 32-byte Nostr group ID (h-tag value)
  /// * `relays` - Relay URLs to query
  /// * `since` - Optional Unix timestamp (seconds); only events after this time
  /// * `limit` - Maximum number of events to return
  Future<List<String>> fetchGroupMessages({
    required List<int> nostrGroupId,
    required List<String> relays,
    PlatformInt64? since,
    int? limit,
  });

  /// Fetches a user's `KeyPackage` (kind 443).
  ///
  /// First fetches the user's KeyPackage relay list (kind 10051),
  /// then fetches the most recent KeyPackage from those relays.
  ///
  /// # Arguments
  ///
  /// * `pubkey` - The user's public key (hex or npub format)
  ///
  /// # Returns
  ///
  /// The KeyPackage event as JSON, or `None` if not found.
  /// Returns the event JSON so Flutter can cache and use it for circle creation.
  Future<String?> fetchKeypackage({required String pubkey});

  /// Fetches a user's `KeyPackage` relay list (kind 10051).
  ///
  /// Returns the relay URLs where the user publishes their KeyPackages.
  /// Used to discover where to fetch a user's KeyPackage for inviting them.
  ///
  /// # Arguments
  ///
  /// * `pubkey` - The user's public key (hex or npub format)
  ///
  /// # Returns
  ///
  /// List of relay URLs, or empty if no relay list is published.
  Future<List<String>> fetchKeypackageRelays({required String pubkey});

  /// Fetches a user's `KeyPackage` with their relay list.
  ///
  /// Convenience method that returns both the KeyPackage and the relays
  /// where it was fetched, bundled for circle creation.
  ///
  /// # Arguments
  ///
  /// * `pubkey` - The user's public key (hex or npub format)
  ///
  /// # Returns
  ///
  /// A `MemberKeyPackageFfi` with the key package and inbox relays,
  /// or `None` if no KeyPackage was found.
  Future<MemberKeyPackageFfi?> fetchMemberKeypackage({required String pubkey});

  /// Gets the connection status of all relays.
  Future<List<RelayConnectionStatusFfi>> getRelayStatus();

  /// Creates a new relay manager.
  static Future<RelayManagerFfi> newInstance() =>
      RustLib.instance.api.crateApiRelayManagerFfiNewInstance();

  /// Publishes a signed event to the specified relays.
  ///
  /// # Arguments
  ///
  /// * `event_json` - JSON-serialized signed Nostr event
  /// * `relays` - List of relay URLs (must be wss://)
  Future<PublishResultFfi> publishEvent({
    required String eventJson,
    required List<String> relays,
  });

  /// Disconnects from all relays.
  Future<void> shutdown();
}

/// Result of circle creation (FFI-friendly).
class CircleCreationResultFfi {
  /// The created circle.
  final CircleFfi circle;

  /// Gift-wrapped Welcome events ready to publish to recipients.
  /// Each is a kind 1059 event containing an encrypted kind 444 Welcome.
  final List<GiftWrappedWelcomeFfi> welcomeEvents;

  const CircleCreationResultFfi({
    required this.circle,
    required this.welcomeEvents,
  });

  @override
  int get hashCode => circle.hashCode ^ welcomeEvents.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleCreationResultFfi &&
          runtimeType == other.runtimeType &&
          circle == other.circle &&
          welcomeEvents == other.welcomeEvents;
}

/// Circle information (FFI-friendly).
///
/// Represents a location sharing circle (group of people).
class CircleFfi {
  /// MLS group ID (opaque bytes, used for API calls).
  final Uint8List mlsGroupId;

  /// Nostr group ID (32 bytes, used in h-tags for relay routing).
  final Uint8List nostrGroupId;

  /// User-facing display name (local only).
  final String displayName;

  /// Circle type: "location_sharing" or "direct_share".
  final String circleType;

  /// Relay URLs for this circle's messages.
  final List<String> relays;

  /// When the circle was created (Unix timestamp).
  final PlatformInt64 createdAt;

  /// When the circle was last updated (Unix timestamp).
  final PlatformInt64 updatedAt;

  const CircleFfi({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.displayName,
    required this.circleType,
    required this.relays,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      displayName.hashCode ^
      circleType.hashCode ^
      relays.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleFfi &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          displayName == other.displayName &&
          circleType == other.circleType &&
          relays == other.relays &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Circle member with resolved local contact info (FFI-friendly).
class CircleMemberFfi {
  /// Nostr public key (hex) - always available.
  final String pubkey;

  /// Display name from local Contact, if set.
  final String? displayName;

  /// Avatar path from local Contact, if set.
  final String? avatarPath;

  /// Whether this member is a group admin.
  final bool isAdmin;

  const CircleMemberFfi({
    required this.pubkey,
    this.displayName,
    this.avatarPath,
    required this.isAdmin,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^
      displayName.hashCode ^
      avatarPath.hashCode ^
      isAdmin.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleMemberFfi &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          displayName == other.displayName &&
          avatarPath == other.avatarPath &&
          isAdmin == other.isAdmin;
}

/// Circle with its membership and member list (FFI-friendly).
class CircleWithMembersFfi {
  /// The circle.
  final CircleFfi circle;

  /// User's membership status: "pending", "accepted", or "declined".
  final String membershipStatus;

  /// Public key of who invited us (if known).
  final String? inviterPubkey;

  /// Members with resolved contact info.
  final List<CircleMemberFfi> members;

  const CircleWithMembersFfi({
    required this.circle,
    required this.membershipStatus,
    this.inviterPubkey,
    required this.members,
  });

  @override
  int get hashCode =>
      circle.hashCode ^
      membershipStatus.hashCode ^
      inviterPubkey.hashCode ^
      members.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CircleWithMembersFfi &&
          runtimeType == other.runtimeType &&
          circle == other.circle &&
          membershipStatus == other.membershipStatus &&
          inviterPubkey == other.inviterPubkey &&
          members == other.members;
}

/// Local contact information (FFI-friendly).
///
/// **Privacy Note**: This data is stored only on the user's device,
/// never synced to Nostr relays. Each user assigns their own names
/// and avatars to contacts (like phone contacts).
class ContactFfi {
  /// Nostr public key (hex) - the ONLY identifier visible to relays.
  final String pubkey;

  /// Locally assigned display name.
  final String? displayName;

  /// Local file path to avatar image.
  final String? avatarPath;

  /// Optional notes about this contact.
  final String? notes;

  /// When this contact was created (Unix timestamp).
  final PlatformInt64 createdAt;

  /// When this contact was last updated (Unix timestamp).
  final PlatformInt64 updatedAt;

  const ContactFfi({
    required this.pubkey,
    this.displayName,
    this.avatarPath,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^
      displayName.hashCode ^
      avatarPath.hashCode ^
      notes.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactFfi &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          displayName == other.displayName &&
          avatarPath == other.avatarPath &&
          notes == other.notes &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Decrypted location from a peer (FFI-friendly).
///
/// Contains the sender identity and location data.
class DecryptedLocationFfi {
  /// Sender's Nostr public key (hex-encoded).
  final String senderPubkey;

  /// Latitude (obfuscated to sender's precision).
  final double latitude;

  /// Longitude (obfuscated to sender's precision).
  final double longitude;

  /// Geohash of the location.
  final String geohash;

  /// When the location was recorded (Unix seconds).
  final PlatformInt64 timestamp;

  /// When this location expires (Unix seconds).
  final PlatformInt64 expiresAt;

  /// Precision level ("Private", "Standard", or "Enhanced").
  final String precision;

  const DecryptedLocationFfi({
    required this.senderPubkey,
    required this.latitude,
    required this.longitude,
    required this.geohash,
    required this.timestamp,
    required this.expiresAt,
    required this.precision,
  });

  @override
  int get hashCode =>
      senderPubkey.hashCode ^
      latitude.hashCode ^
      longitude.hashCode ^
      geohash.hashCode ^
      timestamp.hashCode ^
      expiresAt.hashCode ^
      precision.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DecryptedLocationFfi &&
          runtimeType == other.runtimeType &&
          senderPubkey == other.senderPubkey &&
          latitude == other.latitude &&
          longitude == other.longitude &&
          geohash == other.geohash &&
          timestamp == other.timestamp &&
          expiresAt == other.expiresAt &&
          precision == other.precision;
}

/// Encrypted location event ready for relay publishing (FFI-friendly).
///
/// Contains the signed kind 445 event and routing metadata.
class EncryptedLocationFfi {
  /// JSON-serialized signed Nostr event (kind 445).
  final String eventJson;

  /// Nostr group ID (32 bytes, for h-tag relay routing).
  final Uint8List nostrGroupId;

  /// Relay URLs to publish to.
  final List<String> relays;

  const EncryptedLocationFfi({
    required this.eventJson,
    required this.nostrGroupId,
    required this.relays,
  });

  @override
  int get hashCode =>
      eventJson.hashCode ^ nostrGroupId.hashCode ^ relays.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptedLocationFfi &&
          runtimeType == other.runtimeType &&
          eventJson == other.eventJson &&
          nostrGroupId == other.nostrGroupId &&
          relays == other.relays;
}

/// A gift-wrapped Welcome ready for publishing (FFI-friendly).
///
/// Contains the kind 1059 gift-wrapped event along with recipient
/// information needed for relay publishing.
class GiftWrappedWelcomeFfi {
  /// The recipient's Nostr public key (hex).
  final String recipientPubkey;

  /// Relay URLs to publish this Welcome to (recipient's inbox relays).
  final List<String> recipientRelays;

  /// The gift-wrapped event JSON (kind 1059), ready to publish.
  final String eventJson;

  const GiftWrappedWelcomeFfi({
    required this.recipientPubkey,
    required this.recipientRelays,
    required this.eventJson,
  });

  @override
  int get hashCode =>
      recipientPubkey.hashCode ^ recipientRelays.hashCode ^ eventJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GiftWrappedWelcomeFfi &&
          runtimeType == other.runtimeType &&
          recipientPubkey == other.recipientPubkey &&
          recipientRelays == other.recipientRelays &&
          eventJson == other.eventJson;
}

/// Pending invitation to join a circle (FFI-friendly).
class InvitationFfi {
  /// MLS group ID.
  final Uint8List mlsGroupId;

  /// Circle name.
  final String circleName;

  /// Public key (hex) of who invited us.
  final String inviterPubkey;

  /// Number of members in the circle.
  final int memberCount;

  /// When we were invited (Unix timestamp).
  final PlatformInt64 invitedAt;

  const InvitationFfi({
    required this.mlsGroupId,
    required this.circleName,
    required this.inviterPubkey,
    required this.memberCount,
    required this.invitedAt,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      circleName.hashCode ^
      inviterPubkey.hashCode ^
      memberCount.hashCode ^
      invitedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InvitationFfi &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          circleName == other.circleName &&
          inviterPubkey == other.inviterPubkey &&
          memberCount == other.memberCount &&
          invitedAt == other.invitedAt;
}

/// Key package bundle for publishing (FFI-friendly).
///
/// Contains the data needed to build a kind 443 Nostr event.
class KeyPackageBundleFfi {
  /// Hex-encoded serialized key package (event content).
  final String content;

  /// Tags to include in the event.
  final List<List<String>> tags;

  /// Relay URLs where this key package will be published.
  final List<String> relays;

  const KeyPackageBundleFfi({
    required this.content,
    required this.tags,
    required this.relays,
  });

  @override
  int get hashCode => content.hashCode ^ tags.hashCode ^ relays.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageBundleFfi &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          tags == other.tags &&
          relays == other.relays;
}

/// A member's key package with their inbox relay list (FFI-friendly).
///
/// Used when adding members to a circle. The inbox relays are fetched
/// from the member's kind 10051 relay list and used for publishing
/// the gift-wrapped Welcome.
class MemberKeyPackageFfi {
  /// The key package event JSON (kind 443).
  final String keyPackageJson;

  /// Relay URLs where the Welcome should be sent (from kind 10051).
  final List<String> inboxRelays;

  const MemberKeyPackageFfi({
    required this.keyPackageJson,
    required this.inboxRelays,
  });

  @override
  int get hashCode => keyPackageJson.hashCode ^ inboxRelays.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemberKeyPackageFfi &&
          runtimeType == other.runtimeType &&
          keyPackageJson == other.keyPackageJson &&
          inboxRelays == other.inboxRelays;
}

/// Public identity information (FFI-friendly).
///
/// Contains only public data that can be safely stored and shared.
class PublicIdentity {
  /// Public key as 64-character hex string.
  final String pubkeyHex;

  /// Public key in NIP-19 bech32 format (npub1...).
  final String npub;

  /// When this identity was created (Unix timestamp).
  final PlatformInt64 createdAt;

  const PublicIdentity({
    required this.pubkeyHex,
    required this.npub,
    required this.createdAt,
  });

  @override
  int get hashCode => pubkeyHex.hashCode ^ npub.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicIdentity &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          npub == other.npub &&
          createdAt == other.createdAt;
}

/// Result of publishing an event (FFI-friendly).
class PublishResultFfi {
  /// The event ID that was published (64-char hex).
  final String eventId;

  /// Relays that accepted the event.
  final List<String> acceptedBy;

  /// Relays that rejected the event (URL, reason pairs).
  final List<RelayRejectionFfi> rejectedBy;

  /// Relays that failed to respond.
  final List<String> failed;

  /// Whether at least one relay accepted the event.
  final bool isSuccess;

  const PublishResultFfi({
    required this.eventId,
    required this.acceptedBy,
    required this.rejectedBy,
    required this.failed,
    required this.isSuccess,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      acceptedBy.hashCode ^
      rejectedBy.hashCode ^
      failed.hashCode ^
      isSuccess.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublishResultFfi &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          acceptedBy == other.acceptedBy &&
          rejectedBy == other.rejectedBy &&
          failed == other.failed &&
          isSuccess == other.isSuccess;
}

/// Relay connection status (FFI-friendly).
class RelayConnectionStatusFfi {
  /// The relay URL.
  final String url;

  /// Connection status: "connected", "disconnected", "connecting", or "failed".
  final String status;

  /// Last time the relay was seen (Unix timestamp), if known.
  final PlatformInt64? lastSeen;

  const RelayConnectionStatusFfi({
    required this.url,
    required this.status,
    this.lastSeen,
  });

  @override
  int get hashCode => url.hashCode ^ status.hashCode ^ lastSeen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RelayConnectionStatusFfi &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          status == other.status &&
          lastSeen == other.lastSeen;
}

/// Relay rejection info (FFI-friendly).
class RelayRejectionFfi {
  /// Relay URL that rejected.
  final String url;

  /// Rejection reason.
  final String reason;

  const RelayRejectionFfi({required this.url, required this.reason});

  @override
  int get hashCode => url.hashCode ^ reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RelayRejectionFfi &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          reason == other.reason;
}

/// Generic signed event for FFI use.
class SignedEventFfi {
  /// Event ID (hex).
  final String id;

  /// Event kind.
  final int kind;

  /// Event content.
  final String content;

  /// Event tags.
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Public key (hex) of the event creator.
  final String pubkey;

  /// Signature (hex).
  final String sig;

  const SignedEventFfi({
    required this.id,
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
    required this.pubkey,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      kind.hashCode ^
      content.hashCode ^
      tags.hashCode ^
      createdAt.hashCode ^
      pubkey.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignedEventFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt &&
          pubkey == other.pubkey &&
          sig == other.sig;
}

/// Signed location event (FFI wrapper for outer event kind 445).
///
/// This is the outer event ready for relay transmission.
/// Contains encrypted content signed with an ephemeral keypair.
class SignedLocationEventFfi {
  /// Event ID (SHA256 hash, 64 hex chars).
  final String id;

  /// Ephemeral public key (64 hex chars).
  final String pubkey;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Event kind (445 for Marmot group messages).
  final int kind;

  /// Event tags: `[["h", group_id], ["expiration", ts], ...]`.
  final List<List<String>> tags;

  /// NIP-44 encrypted content (base64).
  final String content;

  /// Schnorr signature (128 hex chars).
  final String sig;

  const SignedLocationEventFfi({
    required this.id,
    required this.pubkey,
    required this.createdAt,
    required this.kind,
    required this.tags,
    required this.content,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      pubkey.hashCode ^
      createdAt.hashCode ^
      kind.hashCode ^
      tags.hashCode ^
      content.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          kind == other.kind &&
          tags == other.tags &&
          content == other.content &&
          sig == other.sig;
}

/// Unsigned Nostr event (FFI-friendly).
///
/// Generic unsigned event for FFI use.
class UnsignedEventFfi {
  /// Event kind.
  final int kind;

  /// Event content.
  final String content;

  /// Event tags.
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  /// Public key (hex) of the event creator (may be empty for unsigned).
  final String pubkey;

  const UnsignedEventFfi({
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
    required this.pubkey,
  });

  @override
  int get hashCode =>
      kind.hashCode ^
      content.hashCode ^
      tags.hashCode ^
      createdAt.hashCode ^
      pubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedEventFfi &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt &&
          pubkey == other.pubkey;
}

/// Unsigned location event (FFI wrapper for inner event kind 30078).
///
/// This is the inner event containing location data before encryption.
/// It is wrapped in a kind 445 group message for transmission.
class UnsignedLocationEventFfi {
  /// Event kind (30078 for location data).
  final int kind;

  /// JSON-serialized location data.
  final String content;

  /// Event tags (typically empty for inner events).
  final List<List<String>> tags;

  /// Unix timestamp when the event was created.
  final PlatformInt64 createdAt;

  const UnsignedLocationEventFfi({
    required this.kind,
    required this.content,
    required this.tags,
    required this.createdAt,
  });

  @override
  int get hashCode =>
      kind.hashCode ^ content.hashCode ^ tags.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsignedLocationEventFfi &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          content == other.content &&
          tags == other.tags &&
          createdAt == other.createdAt;
}

/// Update group result (FFI-friendly).
///
/// Returned after add/remove members or leave operations.
class UpdateGroupResultFfi {
  /// Evolution event (kind 445) to publish to the group relays.
  final SignedEventFfi evolutionEvent;

  /// Welcome events (kind 444) for newly added members (if any).
  final List<UnsignedEventFfi> welcomeEvents;

  const UpdateGroupResultFfi({
    required this.evolutionEvent,
    required this.welcomeEvents,
  });

  @override
  int get hashCode => evolutionEvent.hashCode ^ welcomeEvents.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateGroupResultFfi &&
          runtimeType == other.runtimeType &&
          evolutionEvent == other.evolutionEvent &&
          welcomeEvents == other.welcomeEvents;
}
